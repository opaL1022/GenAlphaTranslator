{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;;;UAAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;ACtBa;AACb,aAAa,mBAAO,CAAC,2DAA2B;AAChD;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS,QAAQ;AACjB,uBAAuB,mBAAmB,GAAG;AAC7C;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,KAAK;AACL;AACA","sources":["webpack://genalphatranslator/webpack/bootstrap","webpack://genalphatranslator/./src/content.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nconst dict = require('../public/dictionary.json');\nconst dictArray = Object.values(dict).flat();\nconst regex = /(\\s+|[.,!?;(){}[\\]\"':])/;\nconst textContainer = document.getElementById(\"text-container\");\nlet originalTextMap = new Map();\nif (!dict) {\n    console.log(\"dictionary.json is empty\");\n}\nconsole.log(dict);\nconsole.log('Content script loaded!');\nfunction ensureDomReady(callback) {\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\n        callback();\n    }\n    else {\n        // 如果 DOM 尚未準備好，等到 loaded 時再執行 callback\n        window.addEventListener('DOMContentLoaded', callback, { once: true });\n    }\n}\nlet density = 0;\nlet curState = false;\nlet debounceTimer = null;\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === \"enable\") {\n        ensureDomReady(enableFeature);\n        curState = true;\n        sendResponse({ status: \"success\" });\n    }\n    else if (message.action === \"disable\") {\n        disableFeature();\n        curState = false;\n        sendResponse({ status: \"success\" });\n    }\n    else if (message.sliderValue !== undefined && curState) {\n        console.log(\"Received slider value:\", message.sliderValue);\n        density = message.sliderValue;\n        if (debounceTimer) {\n            clearTimeout(debounceTimer);\n        }\n        debounceTimer = setTimeout(() => {\n            restoreOriginalText();\n            setTimeout(() => {\n                clearModifiedTags();\n            }, 0);\n            setTimeout(() => {\n                ensureDomReady(enableFeature);\n            }, 0);\n        }, 300); // 延遲 300 毫秒發送訊息，根據需求調整時間\n        sendResponse({ status: \"success\" }); // 回應消息\n        return true;\n    }\n    else {\n        sendResponse({ status: \"failed\" });\n    }\n});\nfunction enableFeature() {\n    console.log(\"功能已啟用\");\n    const convertText = (node) => {\n        if (node.nodeType === Node.TEXT_NODE) {\n            const parent = node.parentElement;\n            // 如果該節點未被修改過，則儲存原始文本並進行修改\n            if (parent && !parent.hasAttribute('data-modified')) {\n                let context = [];\n                // 儲存原始文本\n                if (node.nodeValue !== null && !originalTextMap.has(node)) {\n                    originalTextMap.set(node, node.nodeValue); // 保存原始文本\n                    console.log('Original text saved:', node.nodeValue);\n                }\n                if (node.nodeValue) {\n                    let texts = node.nodeValue.split(regex).filter(Boolean);\n                    for (let i = 0; i < texts.length; i++) {\n                        let word = texts[i].toLowerCase();\n                        let cap = /^[A-Z]$/.test(texts[i].charAt(0));\n                        if (regex.test(texts[i].charAt(0))) {\n                            context.push(texts[i]);\n                        }\n                        else if (word in dict) {\n                            let textLen = dict[word].length;\n                            let textIndex = Math.floor(Math.random() * textLen);\n                            let text = dict[word][textIndex]; // 隨機替換文本\n                            context.push(cap ? text.charAt(0).toUpperCase() + text.slice(1) : text);\n                        }\n                        else {\n                            const randomNum = Math.floor(Math.random() * 100);\n                            if (randomNum < density) {\n                                const dictLen = dictArray.length;\n                                const dictRandNum = Math.floor(Math.random() * dictLen);\n                                let text = dictArray[dictRandNum]; // 隨機替換文本\n                                context.push(cap ? text.charAt(0).toUpperCase() + text.slice(1) : text);\n                            }\n                            else {\n                                context.push(texts[i]);\n                            }\n                        }\n                    }\n                }\n                // 修改文本並標註已修改\n                node.nodeValue = context.join('');\n                parent.setAttribute('data-modified', 'true');\n                console.log('Text modified:', node.nodeValue);\n            }\n        }\n    };\n    const traverseAndModify = (root) => {\n        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {\n            acceptNode: (node) => {\n                const parent = node.parentNode;\n                if (parent && ['SCRIPT', 'STYLE', 'TEXTAREA'].includes(parent.tagName)) {\n                    return NodeFilter.FILTER_REJECT; // 跳過不處理\n                }\n                return NodeFilter.FILTER_ACCEPT;\n            },\n        });\n        let node;\n        while ((node = walker.nextNode())) {\n            convertText(node);\n        }\n    };\n    traverseAndModify(document.body); // 遍歷並修改頁面文本\n    // 設置監聽，處理新增節點和修改的文本\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.addedNodes.forEach((node) => {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    traverseAndModify(node);\n                }\n            });\n            if (mutation.type === 'characterData') {\n                convertText(mutation.target);\n            }\n        });\n    });\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        characterData: true,\n    });\n}\nfunction disableFeature() {\n    console.log(\"功能已禁用\");\n    //window.location.reload();\n    restoreOriginalText();\n    setTimeout(() => {\n        clearModifiedTags();\n    }, 0);\n}\nfunction restoreOriginalText() {\n    // 恢復所有已修改節點的原始文本\n    originalTextMap.forEach((originalText, node) => {\n        if (node.nodeType === Node.TEXT_NODE) {\n            node.nodeValue = originalText; // 恢復原始文本\n            originalTextMap.delete(node); // 刪除已恢復的文本映射\n        }\n    });\n    console.log(\"所有文本已恢复原状\");\n}\nfunction clearModifiedTags() {\n    // 獲取所有已標記為修改過的元素\n    const modifiedNodes = document.querySelectorAll('[data-modified=\"true\"]');\n    modifiedNodes.forEach((node) => {\n        // 只有在元素節點的情況下才移除標籤\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            const parent = node;\n            parent.removeAttribute('data-modified'); // 清除標籤\n        }\n    });\n    console.log(\"所有已修改的标记已清除\");\n}\n"],"names":[],"sourceRoot":""}